#include <algorithm>
#include <cstdint>
#include <cstring>
#include <sstream>
#include <stdexcept>
#include <vector>

#include <vulkan/vulkan.hpp>
#include <vulkan/vulkan_raii.hpp>

#include <vulkan/vk_platform.h>
#include <vulkan/vulkan_core.h>
#include <vulkan/vulkan_enums.hpp>
#include <vulkan/vulkan_handles.hpp>
#include <vulkan/vulkan_structs.hpp>

#include <spdlog/spdlog.h>

#include "arcticvox/common/engine_configuration.hpp"
#include "arcticvox/graphics/gpu.hpp"
#include "arcticvox/graphics/window.hpp"

namespace arcticvox::graphics {

VKAPI_ATTR VkResult VKAPI_CALL create_debug_utils_messenger_ext(
    VkInstance instance,
    const VkDebugUtilsMessengerCreateInfoEXT* create_info,
    const VkAllocationCallbacks* allocator,
    VkDebugUtilsMessengerEXT* messenger) {
    auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(
        instance, "vkCreateDebugUtilsMessengerEXT");
    if(!func)
        return VK_ERROR_EXTENSION_NOT_PRESENT;

    return func(instance, create_info, allocator, messenger);
}

VKAPI_ATTR void VKAPI_CALL destroy_debug_utils_messenger_exit(
    VkInstance instance,
    VkDebugUtilsMessengerEXT messenger,
    VkAllocationCallbacks const* allocator) {
    auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(
        instance, "vkDestroyDebugUtilsMessengerEXT");
    if(func)
        func(instance, messenger, allocator);
}
/**
 * @brief The callback function for debug messages generated by Vulkan
 *
 * @param msg_severity  The severitiy of the message
 * @param msg_types     The flags associated with the message
 * @param cb_data       The debug data
 * @param user_data   Optional user data that is usually empty
 * @return Always returns false
 */
static VKAPI_ATTR VkBool32 VKAPI_CALL debug_message_cb(
    vk::DebugUtilsMessageSeverityFlagBitsEXT msg_severity,
    vk::DebugUtilsMessageTypeFlagsEXT msg_types,
    const vk::DebugUtilsMessengerCallbackDataEXT* cb_data,
    [[maybe_unused]] void* user_data) {
    std::stringstream msg;
    msg << vk::to_string(msg_severity) << ": " << vk::to_string(msg_types) << ":\n";
    msg << "\t" << "Msg ID Name: <" << cb_data->pMessageIdName << ">\n";
    msg << "\t" << "Msg ID Number: <" << cb_data->messageIdNumber << ">\n";
    msg << "\t" << "Msg: <" << cb_data->pMessage << ">\n";

    if(cb_data->queueLabelCount) {
        msg << "\t" << "Queue Labels:\n";

        for(std::size_t i = 0; i < cb_data->queueLabelCount; ++i) {
            msg << "\t\t" << "Label name: <" << cb_data->pQueueLabels[i].pLabelName << ">\n";
        }
    }

    if(cb_data->objectCount) {
        msg << "\t" << "Objects:\n";
        for(std::size_t i = 0; i < cb_data->objectCount; ++i) {
            msg << "\t\t" << "Object " << i << "\n";
            msg << "\t\t\t" << "Object Type: <"
                << vk::to_string(static_cast<vk::ObjectType>(cb_data->pObjects[i].objectType))
                << ">\n";
            msg << "\t\t\t" << "Object Handle: <" << cb_data->pObjects[i].objectHandle << ">\n";

            if(cb_data->pObjects[i].pObjectName)
                msg << "\t\t\t" << "Object Name: <" << cb_data->pObjects[i].pObjectName << ">\n";
        }
    }

    spdlog::error("{}", msg.str());

    return false;
}

gpu::gpu(engine_configuration& config, window& window) :
    config_(config),
    window_(window),
    ctx_(),
    app_info_(vk::ApplicationInfo {.pApplicationName = config.app_name,
                                   .applicationVersion = config.app_version,
                                   .pEngineName = engine_configuration::engine_name,
                                   .engineVersion = engine_configuration::engine_version,
                                   .apiVersion = ctx_.enumerateInstanceVersion()}),
    instance_(create_instance()),
    debug_messenger_(create_debug_utils_messenger()),
    surface_(create_surface()),
    physical_device_(create_physical_device()) { }

vk::raii::Instance gpu::create_instance() {
    const std::vector<vk::LayerProperties> instance_layer_props =
        ctx_.enumerateInstanceLayerProperties();

    if(!check_validation_layer_support(config_.validation_layers, instance_layer_props))
        throw std::runtime_error("Validation layers requested but not available!");

    std::vector<const char*> required_extensions = window_.get_required_glfw_extensions();

    required_extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);

    if(!check_extension_support(required_extensions, ctx_.enumerateInstanceExtensionProperties()))
        throw std::runtime_error("Missing support for required glfw extensions!");

    vk::InstanceCreateInfo instance_create_info {
        .flags = {},
        .pApplicationInfo = &app_info_,
        .enabledLayerCount = static_cast<uint32_t>(config_.validation_layers.size()),
        .ppEnabledLayerNames = config_.validation_layers.data(),
        .enabledExtensionCount = static_cast<uint32_t>(required_extensions.size()),
        .ppEnabledExtensionNames = required_extensions.data()};

    return vk::raii::Instance {ctx_, instance_create_info};
}

vk::raii::DebugUtilsMessengerEXT gpu::create_debug_utils_messenger() {
    vk::DebugUtilsMessageSeverityFlagsEXT severity_flags {
        vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning
        | vk::DebugUtilsMessageSeverityFlagBitsEXT::eError};

    vk::DebugUtilsMessageTypeFlagsEXT message_type_flags {
        vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral
        | vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance
        | vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation};

    vk::DebugUtilsMessengerCreateInfoEXT debug_utils_messenger_info {
        .flags = {},
        .messageSeverity = severity_flags,
        .messageType = message_type_flags,
        .pfnUserCallback = &debug_message_cb};
    return vk::raii::DebugUtilsMessengerEXT {instance_, debug_utils_messenger_info};
}

vk::raii::SurfaceKHR gpu::create_surface() {
    VkSurfaceKHR surface {};
    window_.create_window_surface(*instance_, surface);
    return vk::raii::SurfaceKHR {instance_, surface};
}

vk::raii::PhysicalDevice gpu::create_physical_device() {
    vk::raii::PhysicalDevices phy_devices {instance_};

    if(phy_devices.size() == 0U)
        throw std::runtime_error("Failed to find GPUs with Vulkan support!");

    for(const vk::raii::PhysicalDevice& phy_device: phy_devices) {
        if(check_gpu_suitability(phy_device, config_.device_extensions)) {
            spdlog::info("Using GPU: {}", phy_device.getProperties().deviceName.data());
            return vk::raii::PhysicalDevice {instance_, *phy_device};
        }
    }
    throw std::runtime_error("No suitable GPU found!");
}

bool gpu::check_extension_support(
    const std::vector<const char*>& extensions,
    const std::vector<vk::ExtensionProperties>& available_extensions) {
    // compare each required extension with all available extensions and return the total result
    return std::all_of(extensions.cbegin(),
                       extensions.cend(),
                       [&available_extensions](const char* required_extension) {
                           const bool is_supported = std::any_of(
                               available_extensions.cbegin(),
                               available_extensions.cend(),
                               [&required_extension](const vk::ExtensionProperties& prop) {
                                   return strcmp(required_extension, prop.extensionName) == 0U;
                               });
                           if(is_supported)
                               spdlog::info("Extension {}: supported", required_extension);
                           else
                               spdlog::info("Extension {}: not supported", required_extension);
                           return is_supported;
                       });
}

bool gpu::check_gpu_suitability(vk::raii::PhysicalDevice device,
                                const std::vector<const char*>& extensions) {
    const bool extension_supported =
        check_extension_support(extensions, device.enumerateDeviceExtensionProperties());

    const queue_family_indices indices = find_queue_families(device, surface_);

    bool swapchain_adequate = false;
    if(extension_supported) {
        const swapchain_support_details details = query_swapchain_support(device);
        swapchain_adequate = !details.surface_formats.empty() && !details.present_modes.empty();
    }

    return device.getFeatures().samplerAnisotropy && extension_supported && indices.is_complete()
           && swapchain_adequate;
}

bool gpu::check_validation_layer_support(
    const std::vector<const char*>& layers_to_check,
    const std::vector<vk::LayerProperties>& available_layer_props) {
    return std::all_of(layers_to_check.cbegin(),
                       layers_to_check.cend(),
                       [&available_layer_props](const char* layer) {
                           bool is_supported =
                               std::any_of(available_layer_props.cbegin(),
                                           available_layer_props.cend(),
                                           [&layer](const vk::LayerProperties& props) {
                                               return strcmp(layer, props.layerName) == 0U;
                                           });
                           if(is_supported)
                               spdlog::info("Layer {}: supported", layer);
                           else
                               spdlog::info("Layer {}: not supported", layer);
                           return is_supported;
                       });
}

uint32_t gpu::find_memory_type(const uint32_t type_filter,
                               const vk::MemoryPropertyFlags properties) {
    vk::PhysicalDeviceMemoryProperties memory_properties = physical_device_.getMemoryProperties();

    for(uint32_t i = 0; i < memory_properties.memoryTypeCount; ++i) {
        if((type_filter & (1U << i))
           && (memory_properties.memoryTypes[i].propertyFlags & properties) == properties)
            return i;
    }

    throw std::runtime_error("Failed to find suitable memory type");
}

queue_family_indices gpu::find_queue_families() {
    return find_queue_families(physical_device_, surface_);
}

queue_family_indices gpu::find_queue_families(vk::raii::PhysicalDevice& device,
                                              vk::raii::SurfaceKHR& surface) {
    std::vector<vk::QueueFamilyProperties> queue_families = device.getQueueFamilyProperties();

    for(size_t i = 0U; i < queue_families.size(); ++i) {
        queue_family_indices indices;
        if(queue_families[i].queueCount
           && (queue_families[i].queueFlags & vk::QueueFlagBits::eGraphics))
            indices.graphics_family = i;
        if(queue_families[i].queueCount && device.getSurfaceSupportKHR(i, surface))
            indices.present_family = i;
        if(indices.is_complete())
            return indices;
    }
    return queue_family_indices {std::nullopt, std::nullopt};
}

vk::Format gpu::find_supported_format(const std::vector<vk::Format>& candidates,
                                      const vk::ImageTiling tiling,
                                      const vk::FormatFeatureFlags features) const {
    for(const auto format: candidates) {
        const vk::FormatProperties properties = physical_device_.getFormatProperties(format);

        if((tiling == vk::ImageTiling::eLinear)
           && ((properties.linearTilingFeatures & features) == features))
            return format;
        if((tiling == vk::ImageTiling::eOptimal)
           && (properties.optimalTilingFeatures & features) == features)
            return format;
    }

    throw std::runtime_error("Failed to find supported format");
}

swapchain_support_details gpu::query_swapchain_support() {
    return query_swapchain_support(physical_device_);
}

swapchain_support_details gpu::query_swapchain_support(vk::raii::PhysicalDevice& device) {
    return swapchain_support_details {.surface_capabilities =
                                          device.getSurfaceCapabilitiesKHR(surface_),
                                      .surface_formats = device.getSurfaceFormatsKHR(surface_),
                                      .present_modes = device.getSurfacePresentModesKHR(surface_)};
}

}
